{"version":3,"file":"swipix.cjs.js","sources":["../src/index.js"],"sourcesContent":["/**\n * Swipix - A customizable carousel library\n * Supports infinite looping, built-in tabs (with optional range mapping and multiple tab groups),\n * autoplay with pause on interaction, media lazy loading, and lazy initialization (lazyPix).\n */\nclass Swipix {\n  /**\n   * Create a new carousel instance.\n   * @param {Object} config - Configuration options.\n   * @param {string} config.container - Selector for the carousel container (default: '.pix-container')\n   * @param {string|null} config.nextButton - Selector for next button (null for no button)\n   * @param {string|null} config.prevButton - Selector for previous button (null for no button)\n   * @param {boolean} config.loop - Enable standard looping (has no effect when infiniteLoop is true)\n   * @param {boolean} config.infiniteLoop - Enable true infinite sliding with cloned slides\n   * @param {number} config.speed - Transition speed in milliseconds\n   * @param {Object} config.slidesPerView - Number of slides to show based on viewport (e.g., { default: 1, 768: 2, 1024: 3 })\n   * @param {number} config.gap - Gap between slides in pixels\n   * @param {number} config.slidesToMove - Number of slides to move per navigation action\n   * @param {Object|Array} [config.tabsConfig] - Optional configuration for tab buttons.\n   * @param {Object} [config.autoplay] - Autoplay configuration: { enabled: true, delay: 3000, pauseOnInteraction: true, pauseAfterInteraction: false }\n   * @param {boolean} [config.lazyMedia] - When true, media inside slides (img/video with data-src) will be lazy loaded when visible.\n   * @param {number} [config.lazyMediaOffset] - Offset in pixels for triggering lazy media load (default: 100).\n   * @param {boolean} [config.lazyPix] - When true, the carousel will not initialize until its container is near the viewport.\n   * @param {number} [config.lazyPixOffset] - Offset in pixels used with IntersectionObserver to trigger lazy initialization (default: 150).\n   */\n  constructor(config) {\n    this.config = {\n      container: '.pix-container',\n      nextButton: null,\n      prevButton: null,\n      loop: false,\n      infiniteLoop: false,\n      speed: 300,\n      slidesPerView: { default: 1 },\n      gap: 0,\n      slidesToMove: 1,\n      autoplay: { enabled: false, delay: 3000, pauseOnInteraction: false, pauseAfterInteraction: false },\n      lazyMedia: false,\n      lazyMediaOffset: 100,\n      lazyPix: false,\n      lazyPixOffset: 150,\n      ...config\n    };\n\n    this.state = {\n      currentIndex: 0,\n      totalSlides: 0,\n      slideWidth: 0,\n      isAnimating: false,\n      containerWidth: 0,\n      slidesPerView: 1,\n      carousels: []\n    };\n  }\n\n  init(containerSelector = null) {\n    const selector = containerSelector || this.config.container;\n    const containers = document.querySelectorAll(selector);\n\n    containers.forEach(container => {\n      // If lazyPix is enabled, delay initialization using an observer.\n      if (this.config.lazyPix) {\n        this._observeInit(container);\n      } else {\n        this._initSingleCarousel(container);\n      }\n    });\n    window.addEventListener('resize', this._handleResize.bind(this));\n    if (this.config.autoplay.enabled) {\n      this.state.carousels.forEach(carouselData => {\n        this._setupAutoplay(carouselData);\n      });\n    }\n    return this;\n  }\n\n  _observeInit(container) {\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          this._initSingleCarousel(container);\n          observer.unobserve(container);\n        }\n      });\n    }, { threshold: 0, rootMargin: `${this.config.lazyPixOffset}px` });\n    observer.observe(container);\n  }\n\n  _initSingleCarousel(container) {\n    const wrapper = container.querySelector('.pix-wrapper');\n    const slides = container.querySelectorAll('.pix-slide');\n    if (!wrapper || slides.length === 0) {\n      console.error('Carousel structure is invalid. Ensure you have .pix-wrapper and .pix-slide elements.');\n      return;\n    }\n    // If infiniteLoop is enabled, hide the container initially to prevent the flash of cloned slides.\n    if (this.config.infiniteLoop) {\n      container.style.visibility = 'hidden';\n    }\n    const originalSlides = Array.from(slides).map((slide, index) => {\n      slide.setAttribute('data-swipix-index', index);\n      return slide;\n    });\n    const carouselData = {\n      container,\n      wrapper,\n      slides: Array.from(slides),\n      originalSlides,\n      currentIndex: 0,\n      isInfinite: this.config.infiniteLoop,\n      clonedSlides: [],\n      realSlidesOffset: 0,\n      autoplayInterval: null,\n      autoplayHandlers: null,\n      tabGroups: [],\n      isVisible: false\n    };\n    this.state.carousels.push(carouselData);\n    this._applyStyles(carouselData);\n    if (this.config.infiniteLoop) {\n      this._setupInfiniteLoop(carouselData);\n    }\n    this._calculateDimensions(carouselData);\n    // Disable transition temporarily, position slides, force reflow, then restore transition.\n    carouselData.wrapper.style.transition = 'none';\n    this._positionSlides(carouselData);\n    void carouselData.wrapper.offsetWidth;\n    carouselData.wrapper.style.transition = `transform ${this.config.speed}ms ease`;\n    // Reveal the container once positioning is complete.\n    if (this.config.infiniteLoop) {\n      container.style.visibility = 'visible';\n    }\n    this._initNavigation(carouselData);\n    this._initTouchEvents(carouselData);\n    if (this.config.tabsConfig) {\n      this._initTabsGroups(carouselData);\n    }\n    if (this.config.lazyMedia) {\n      this._observeVisibility(carouselData);\n    }\n    if (this.config.autoplay.enabled && this.config.autoplay.pauseOnInteraction) {\n      const pauseHandler = () => {\n        this._pauseAutoplay(carouselData);\n        if (this.config.autoplay.pauseAfterInteraction) {\n          carouselData.container.removeEventListener('mouseleave', resumeHandler);\n        }\n      };\n      const resumeHandler = () => {\n        if (!this.config.autoplay.pauseAfterInteraction) {\n          this._startAutoplay(carouselData);\n        }\n      };\n      carouselData.autoplayHandlers = { pauseHandler, resumeHandler };\n      container.addEventListener('mouseenter', pauseHandler);\n      container.addEventListener('mouseleave', resumeHandler);\n    }\n  }\n\n  _observeVisibility(carouselData) {\n    const container = carouselData.container;\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        carouselData.isVisible = entry.isIntersecting;\n        if (entry.isIntersecting && this.config.lazyMedia) {\n          this._lazyLoadMedia(carouselData);\n        }\n      });\n    }, { threshold: 0.1, rootMargin: `${this.config.lazyMediaOffset}px` });\n    observer.observe(container);\n    carouselData.visibilityObserver = observer;\n  }\n\n  _setupAutoplay(carouselData) {\n    this._startAutoplay(carouselData);\n  }\n\n  _startAutoplay(carouselData) {\n    this._pauseAutoplay(carouselData);\n    carouselData.autoplayInterval = setInterval(() => {\n      this.next(carouselData.container);\n    }, this.config.autoplay.delay);\n  }\n\n  _pauseAutoplay(carouselData) {\n    clearInterval(carouselData.autoplayInterval);\n    carouselData.autoplayInterval = null;\n  }\n\n  _lazyLoadMedia(carouselData) {\n    if (!carouselData.isVisible) return;\n    const start = carouselData.currentIndex;\n    const end = start + carouselData.slidesPerView;\n    const visibleSlides = carouselData.slides.slice(start, end);\n    visibleSlides.forEach(slide => {\n      const mediaElements = slide.querySelectorAll('img[data-src], video[data-src]');\n      mediaElements.forEach(media => {\n        const dataSrc = media.getAttribute('data-src');\n        if (dataSrc && !media.getAttribute('src')) {\n          media.setAttribute('src', dataSrc);\n          media.removeAttribute('data-src');\n          if (media.tagName.toLowerCase() === 'video') {\n            media.load();\n          }\n        }\n      });\n    });\n  }\n\n  _initTabsGroups(carouselData) {\n    const tabsConfigOption = this.config.tabsConfig;\n    let tabConfigs = [];\n    if (Array.isArray(tabsConfigOption)) {\n      tabConfigs = tabsConfigOption;\n    } else if (tabsConfigOption && typeof tabsConfigOption === 'object') {\n      tabConfigs = [tabsConfigOption];\n    } else {\n      return;\n    }\n    carouselData.tabGroups = [];\n    tabConfigs.forEach(config => {\n      const tabsContainer = document.querySelector(config.container);\n      if (!tabsContainer) {\n        console.warn(`Tabs container not found for selector ${config.container}`);\n        return;\n      }\n      let buttons;\n      if (config.buttonSelector) {\n        buttons = tabsContainer.querySelectorAll(config.buttonSelector);\n      } else {\n        buttons = tabsContainer.children;\n      }\n      buttons = Array.from(buttons);\n      buttons.forEach((btn, index) => {\n        btn.addEventListener('click', () => {\n          let targetSlide = config.mapping && Array.isArray(config.mapping)\n            ? config.mapping[index]\n            : index;\n          if (targetSlide < 0 || targetSlide >= carouselData.totalSlides) {\n            console.warn(`Mapping for tab index ${index} is out-of-bound.`);\n            return;\n          }\n          this.slideTo(carouselData.container, targetSlide);\n        });\n      });\n      carouselData.tabGroups.push({\n        container: tabsContainer,\n        buttons: buttons,\n        config: config\n      });\n      this._updateTabsActiveGroup(carouselData, config, buttons);\n    });\n  }\n\n  _updateTabsActive(carouselData) {\n    if (!carouselData.tabGroups) return;\n    carouselData.tabGroups.forEach(group => {\n      this._updateTabsActiveGroup(carouselData, group.config, group.buttons);\n    });\n  }\n\n  _updateTabsActiveGroup(carouselData, config, buttons) {\n    let activeIndex = carouselData.currentIndex;\n    if (carouselData.isInfinite) {\n      activeIndex = carouselData.currentIndex - carouselData.realSlidesOffset;\n    }\n    activeIndex = Math.max(0, Math.min(activeIndex, carouselData.totalSlides - 1));\n    const activeClass = config.activeClass || 'active';\n    if (config.rangeMapping && Array.isArray(config.mapping) && config.mapping.length > 0) {\n      let selectedTab = 0;\n      for (let i = 0; i < config.mapping.length; i++) {\n        if (activeIndex >= config.mapping[i]) {\n          selectedTab = i;\n        }\n      }\n      buttons.forEach((btn, i) => {\n        if (i === selectedTab) {\n          btn.classList.add(activeClass);\n        } else {\n          btn.classList.remove(activeClass);\n        }\n      });\n    } else {\n      buttons.forEach((btn, i) => {\n        let mappedSlide = config.mapping && Array.isArray(config.mapping)\n          ? config.mapping[i]\n          : i;\n        if (mappedSlide === activeIndex) {\n          btn.classList.add(activeClass);\n        } else {\n          btn.classList.remove(activeClass);\n        }\n      });\n    }\n  }\n\n  _setupInfiniteLoop(carouselData) {\n    const { wrapper, originalSlides } = carouselData;\n    this._clearClonedSlides(carouselData);\n    const breakpointValues = Object.values(this.config.slidesPerView);\n    const maxSlidesPerView = Math.max(...breakpointValues);\n    const cloneCount = maxSlidesPerView;\n    const beginClones = [];\n    for (let i = 0; i < cloneCount; i++) {\n      const slideIndex = i % originalSlides.length;\n      const clone = originalSlides[slideIndex].cloneNode(true);\n      clone.setAttribute('data-swipix-clone', 'end');\n      clone.setAttribute('data-swipix-original-index', slideIndex);\n      wrapper.appendChild(clone);\n      beginClones.push(clone);\n    }\n    const endClones = [];\n    for (let i = 0; i < cloneCount; i++) {\n      const slideIndex = (originalSlides.length - 1 - i) % originalSlides.length;\n      const clone = originalSlides[slideIndex].cloneNode(true);\n      clone.setAttribute('data-swipix-clone', 'start');\n      clone.setAttribute('data-swipix-original-index', slideIndex);\n      wrapper.insertBefore(clone, wrapper.firstChild);\n      endClones.push(clone);\n    }\n    carouselData.clonedSlides = [...endClones, ...beginClones];\n    carouselData.realSlidesOffset = endClones.length;\n    carouselData.slides = Array.from(wrapper.querySelectorAll('.pix-slide'));\n    carouselData.currentIndex = carouselData.realSlidesOffset;\n  }\n\n  _clearClonedSlides(carouselData) {\n    const { wrapper, clonedSlides } = carouselData;\n    if (clonedSlides && clonedSlides.length) {\n      clonedSlides.forEach(clone => {\n        if (clone.parentNode === wrapper) {\n          wrapper.removeChild(clone);\n        }\n      });\n      carouselData.clonedSlides = [];\n    }\n    carouselData.slides = [...carouselData.originalSlides];\n  }\n\n  _applyStyles(carouselData) {\n    const { container, wrapper, slides } = carouselData;\n    container.style.overflow = 'hidden';\n    container.style.position = 'relative';\n    wrapper.style.display = 'flex';\n    wrapper.style.transition = `transform ${this.config.speed}ms ease`;\n    wrapper.style.willChange = 'transform';\n    slides.forEach(slide => {\n      slide.style.flexShrink = '0';\n      if (this.config.gap > 0) {\n        slide.style.marginRight = `${this.config.gap}px`;\n      }\n    });\n  }\n\n  _calculateDimensions(carouselData) {\n    const { container, slides } = carouselData;\n    const viewportWidth = window.innerWidth;\n    let slidesPerView = this.config.slidesPerView.default;\n    const breakpoints = Object.keys(this.config.slidesPerView)\n      .filter(bp => bp !== 'default')\n      .map(bp => parseInt(bp, 10))\n      .sort((a, b) => b - a);\n    for (const bp of breakpoints) {\n      if (viewportWidth >= bp) {\n        slidesPerView = this.config.slidesPerView[bp];\n        break;\n      }\n    }\n    carouselData.slidesPerView = slidesPerView;\n    carouselData.containerWidth = container.offsetWidth;\n    const totalGapSpace = this.config.gap * (slidesPerView - 1);\n    carouselData.slideWidth = (carouselData.containerWidth - totalGapSpace) / slidesPerView;\n    carouselData.totalSlides = carouselData.originalSlides.length;\n    slides.forEach(slide => {\n      slide.style.width = `${carouselData.slideWidth}px`;\n    });\n    carouselData.gap = this.config.gap;\n    if (carouselData.isInfinite) {\n      this._setupInfiniteLoop(carouselData);\n    }\n    this._positionSlides(carouselData);\n  }\n\n  _positionSlides(carouselData) {\n    const { wrapper, currentIndex, slideWidth, gap } = carouselData;\n    const translateX = -currentIndex * (slideWidth + gap);\n    wrapper.style.transform = `translateX(${translateX}px)`;\n    if (this.config.lazyMedia && carouselData.isVisible) {\n      this._lazyLoadMedia(carouselData);\n    }\n  }\n\n  _checkInfiniteLoopReset(carouselData) {\n    if (!carouselData.isInfinite) return;\n    const { currentIndex, realSlidesOffset, totalSlides, wrapper } = carouselData;\n    const endThreshold = realSlidesOffset + totalSlides;\n    if (currentIndex < realSlidesOffset) {\n      wrapper.style.transition = 'none';\n      carouselData.currentIndex = endThreshold - (realSlidesOffset - currentIndex);\n      this._positionSlides(carouselData);\n      void wrapper.offsetWidth;\n      wrapper.style.transition = `transform ${this.config.speed}ms ease`;\n    } else if (currentIndex >= endThreshold) {\n      wrapper.style.transition = 'none';\n      carouselData.currentIndex = realSlidesOffset + (currentIndex - endThreshold);\n      this._positionSlides(carouselData);\n      void wrapper.offsetWidth;\n      wrapper.style.transition = `transform ${this.config.speed}ms ease`;\n    }\n  }\n\n  _initNavigation(carouselData) {\n    const { container } = carouselData;\n    if (this.config.nextButton) {\n      const nextBtn = container.querySelector(this.config.nextButton) || document.querySelector(this.config.nextButton);\n      if (nextBtn) {\n        nextBtn.addEventListener('click', () => {\n          this.next(container);\n        });\n      }\n    }\n    if (this.config.prevButton) {\n      const prevBtn = container.querySelector(this.config.prevButton) || document.querySelector(this.config.prevButton);\n      if (prevBtn) {\n        prevBtn.addEventListener('click', () => {\n          this.prev(container);\n        });\n      }\n    }\n  }\n\n  _initTouchEvents(carouselData) {\n    const { container, wrapper } = carouselData;\n    let startX, moveX, isDragging = false;\n    let initialTransform = 0;\n    const handleDragStart = (e) => {\n      const targetTag = e.target.tagName.toLowerCase();\n      if (['input', 'button', 'select', 'textarea'].includes(targetTag)) return;\n      e.preventDefault();\n      startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;\n      isDragging = true;\n      const transform = window.getComputedStyle(wrapper).getPropertyValue('transform');\n      const matrix = new DOMMatrix(transform);\n      initialTransform = matrix.m41;\n      wrapper.style.transition = 'none';\n      wrapper.style.cursor = 'grabbing';\n    };\n    const handleDragMove = (e) => {\n      if (!isDragging) return;\n      moveX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;\n      const diff = moveX - startX;\n      let adjustedDiff = diff;\n      if (!carouselData.isInfinite && !this.config.loop) {\n        const maxIndex = carouselData.totalSlides - carouselData.slidesPerView;\n        if (carouselData.currentIndex === 0 && diff > 0) adjustedDiff = diff * 0.3;\n        if (carouselData.currentIndex === maxIndex && diff < 0) adjustedDiff = diff * 0.3;\n      }\n      wrapper.style.transform = `translateX(${initialTransform + adjustedDiff}px)`;\n    };\n    const handleDragEnd = (e) => {\n      if (!isDragging) return;\n      wrapper.style.transition = `transform ${this.config.speed}ms ease`;\n      wrapper.style.cursor = 'grab';\n      const endX = e.type === 'touchend'\n        ? (e.changedTouches ? e.changedTouches[0].clientX : moveX)\n        : e.clientX || moveX;\n      const diff = endX - startX;\n      const maxIndex = carouselData.totalSlides - carouselData.slidesPerView;\n      const isAtStart = carouselData.currentIndex === (carouselData.isInfinite ? carouselData.realSlidesOffset : 0);\n      const isAtEnd = carouselData.currentIndex === (carouselData.isInfinite ? carouselData.realSlidesOffset + maxIndex : maxIndex);\n      if (Math.abs(diff) > 50) {\n        if (diff > 0 && (!isAtStart || this.config.loop || carouselData.isInfinite)) {\n          this.prev(container);\n        } else if (diff < 0 && (!isAtEnd || this.config.loop || carouselData.isInfinite)) {\n          this.next(container);\n        } else {\n          this._positionSlides(carouselData);\n        }\n      } else {\n        this._positionSlides(carouselData);\n      }\n      isDragging = false;\n      const event = new CustomEvent('swipix:slideChanged', {\n        detail: { carousel: this, container, currentIndex: carouselData.currentIndex }\n      });\n      document.dispatchEvent(event);\n    };\n    container.addEventListener('touchstart', handleDragStart, { passive: false });\n    container.addEventListener('touchmove', handleDragMove, { passive: true });\n    container.addEventListener('touchend', handleDragEnd);\n    container.addEventListener('mousedown', handleDragStart);\n    window.addEventListener('mousemove', handleDragMove);\n    window.addEventListener('mouseup', handleDragEnd);\n    wrapper.style.cursor = 'grab';\n    carouselData.eventHandlers = { handleDragStart, handleDragMove, handleDragEnd };\n  }\n\n  _handleResize() {\n    this.state.carousels.forEach(carouselData => {\n      this._calculateDimensions(carouselData);\n    });\n  }\n\n  _getCarouselData(container) {\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n    return this.state.carousels.find(data => data.container === container) || null;\n  }\n\n  next(container) {\n    const carouselData = this._getCarouselData(container);\n    if (!carouselData || carouselData.isAnimating) return this;\n    carouselData.isAnimating = true;\n    const slidesToMove = this.config.slidesToMove;\n    if (carouselData.isInfinite) {\n      carouselData.currentIndex += slidesToMove;\n    } else {\n      const maxIndex = carouselData.totalSlides - carouselData.slidesPerView;\n      if (carouselData.currentIndex + slidesToMove > maxIndex) {\n        if (this.config.loop) {\n          carouselData.currentIndex = 0;\n        } else {\n          carouselData.currentIndex = maxIndex;\n          carouselData.isAnimating = false;\n          return this;\n        }\n      } else {\n        carouselData.currentIndex += slidesToMove;\n      }\n    }\n    this._positionSlides(carouselData);\n    if (carouselData.isInfinite) {\n      setTimeout(() => { this._checkInfiniteLoopReset(carouselData); }, this.config.speed);\n    }\n    setTimeout(() => {\n      carouselData.isAnimating = false;\n      this._updateTabsActive(carouselData);\n      const event = new CustomEvent('swipix:slideChanged', {\n        detail: { carousel: this, container, currentIndex: carouselData.currentIndex }\n      });\n      document.dispatchEvent(event);\n    }, this.config.speed);\n    return this;\n  }\n\n  prev(container) {\n    const carouselData = this._getCarouselData(container);\n    if (!carouselData || carouselData.isAnimating) return this;\n    carouselData.isAnimating = true;\n    const slidesToMove = this.config.slidesToMove;\n    if (carouselData.isInfinite) {\n      carouselData.currentIndex -= slidesToMove;\n    } else {\n      if (carouselData.currentIndex - slidesToMove < 0) {\n        if (this.config.loop) {\n          carouselData.currentIndex = carouselData.totalSlides - carouselData.slidesPerView;\n        } else {\n          carouselData.currentIndex = 0;\n          carouselData.isAnimating = false;\n          return this;\n        }\n      } else {\n        carouselData.currentIndex -= slidesToMove;\n      }\n    }\n    this._positionSlides(carouselData);\n    if (carouselData.isInfinite) {\n      setTimeout(() => { this._checkInfiniteLoopReset(carouselData); }, this.config.speed);\n    }\n    setTimeout(() => {\n      carouselData.isAnimating = false;\n      this._updateTabsActive(carouselData);\n      const event = new CustomEvent('swipix:slideChanged', {\n        detail: { carousel: this, container, currentIndex: carouselData.currentIndex }\n      });\n      document.dispatchEvent(event);\n    }, this.config.speed);\n    return this;\n  }\n\n  goTo(container, index) {\n    const carouselData = this._getCarouselData(container);\n    if (!carouselData || carouselData.isAnimating) return this;\n    carouselData.isAnimating = true;\n    const maxIndex = carouselData.totalSlides - carouselData.slidesPerView;\n    let targetIndex = index;\n    if (carouselData.isInfinite) {\n      targetIndex = index + carouselData.realSlidesOffset;\n    }\n    if (targetIndex < (carouselData.isInfinite ? carouselData.realSlidesOffset : 0)) {\n      carouselData.currentIndex = carouselData.isInfinite ? carouselData.realSlidesOffset : 0;\n    } else if (targetIndex > (carouselData.isInfinite ? carouselData.realSlidesOffset + maxIndex : maxIndex)) {\n      carouselData.currentIndex = carouselData.isInfinite ? carouselData.realSlidesOffset + maxIndex : maxIndex;\n    } else {\n      carouselData.currentIndex = targetIndex;\n    }\n    this._positionSlides(carouselData);\n    setTimeout(() => {\n      carouselData.isAnimating = false;\n      if (carouselData.isInfinite) {\n        this._checkInfiniteLoopReset(carouselData);\n      }\n      this._updateTabsActive(carouselData);\n      const event = new CustomEvent('swipix:slideChanged', {\n        detail: { carousel: this, container, currentIndex: carouselData.currentIndex }\n      });\n      document.dispatchEvent(event);\n    }, this.config.speed);\n    return this;\n  }\n  \n  slideTo(container, index) {\n    if (typeof container === 'number') {\n      index = container;\n      container = this.state.carousels[0].container;\n    }\n    const carouselData = this._getCarouselData(container);\n    if (!carouselData || carouselData.isAnimating) return this;\n    carouselData.isAnimating = true;\n    const totalRealSlides = carouselData.totalSlides;\n    const targetRealIndex = Math.max(0, Math.min(index, totalRealSlides - 1));\n    let targetIndex = targetRealIndex;\n    if (carouselData.isInfinite) {\n      targetIndex = targetRealIndex + carouselData.realSlidesOffset;\n    }\n    carouselData.currentIndex = targetIndex;\n    this._positionSlides(carouselData);\n    if (carouselData.isInfinite) {\n      setTimeout(() => { this._checkInfiniteLoopReset(carouselData); }, this.config.speed);\n    }\n    setTimeout(() => {\n      carouselData.isAnimating = false;\n      this._updateTabsActive(carouselData);\n      const event = new CustomEvent('swipix:slideChanged', {\n        detail: { carousel: this, container, currentIndex: carouselData.currentIndex }\n      });\n      document.dispatchEvent(event);\n    }, this.config.speed);\n    return this;\n  }\n\n  updateConfig(newConfig) {\n    if (newConfig.autoplay) {\n      this.config.autoplay = {\n        enabled: newConfig.autoplay.enabled !== undefined ? newConfig.autoplay.enabled : this.config.autoplay.enabled,\n        delay: newConfig.autoplay.delay !== undefined ? newConfig.autoplay.delay : this.config.autoplay.delay,\n        pauseOnInteraction: newConfig.autoplay.pauseOnInteraction !== undefined ? newConfig.autoplay.pauseOnInteraction : this.config.autoplay.pauseOnInteraction,\n        pauseAfterInteraction: newConfig.autoplay.pauseAfterInteraction !== undefined ? newConfig.autoplay.pauseAfterInteraction : this.config.autoplay.pauseAfterInteraction\n      };\n      delete newConfig.autoplay;\n    }\n    this.config = { ...this.config, ...newConfig };\n    this.state.carousels.forEach(carouselData => {\n      if (this.config.infiniteLoop !== carouselData.isInfinite) {\n        carouselData.isInfinite = this.config.infiniteLoop;\n        if (carouselData.isInfinite) {\n          this._setupInfiniteLoop(carouselData);\n        } else {\n          this._clearClonedSlides(carouselData);\n          carouselData.currentIndex = Math.min(\n            carouselData.currentIndex - carouselData.realSlidesOffset,\n            carouselData.totalSlides - carouselData.slidesPerView\n          );\n          carouselData.currentIndex = Math.max(0, carouselData.currentIndex);\n          carouselData.realSlidesOffset = 0;\n        }\n      }\n      this._applyStyles(carouselData);\n      this._calculateDimensions(carouselData);\n      if (this.config.tabsConfig) {\n        this._initTabsGroups(carouselData);\n      }\n      this._pauseAutoplay(carouselData);\n      if (this.config.autoplay.enabled) {\n        this._startAutoplay(carouselData);\n      }\n      if (this.config.autoplay.enabled && this.config.autoplay.pauseOnInteraction) {\n        if (carouselData.autoplayHandlers) {\n          carouselData.container.removeEventListener('mouseenter', carouselData.autoplayHandlers.pauseHandler);\n          carouselData.container.removeEventListener('mouseleave', carouselData.autoplayHandlers.resumeHandler);\n        }\n        if (this.config.autoplay.pauseAfterInteraction) {\n          const pauseHandler = () => {\n            this._pauseAutoplay(carouselData);\n            carouselData.container.removeEventListener('mouseleave', resumeHandler);\n          };\n          const resumeHandler = () => {};\n          carouselData.autoplayHandlers = { pauseHandler, resumeHandler };\n          carouselData.container.addEventListener('mouseenter', pauseHandler);\n        } else {\n          const pauseHandler = () => this._pauseAutoplay(carouselData);\n          const resumeHandler = () => this._startAutoplay(carouselData);\n          carouselData.autoplayHandlers = { pauseHandler, resumeHandler };\n          carouselData.container.addEventListener('mouseenter', pauseHandler);\n          carouselData.container.addEventListener('mouseleave', resumeHandler);\n        }\n      }\n    });\n    return this;\n  }\n\n  destroy() {\n    window.removeEventListener('resize', this._handleResize.bind(this));\n    this.state.carousels.forEach(carouselData => {\n      const { container, wrapper, slides, eventHandlers } = carouselData;\n      if (carouselData.isInfinite) {\n        this._clearClonedSlides(carouselData);\n      }\n      container.style.overflow = '';\n      container.style.position = '';\n      wrapper.style.display = '';\n      wrapper.style.transition = '';\n      wrapper.style.transform = '';\n      wrapper.style.willChange = '';\n      wrapper.style.cursor = '';\n      slides.forEach(slide => {\n        slide.style.flexShrink = '';\n        slide.style.width = '';\n        slide.style.marginRight = '';\n      });\n      if (eventHandlers) {\n        container.removeEventListener('touchstart', eventHandlers.handleDragStart, { passive: false });\n        container.removeEventListener('touchmove', eventHandlers.handleDragMove, { passive: true });\n        container.removeEventListener('touchend', eventHandlers.handleDragEnd);\n        container.removeEventListener('mousedown', eventHandlers.handleDragStart);\n        window.removeEventListener('mousemove', eventHandlers.handleDragMove);\n        window.removeEventListener('mouseup', eventHandlers.handleDragEnd);\n      }\n      const newContainer = container.cloneNode(true);\n      container.parentNode.replaceChild(newContainer, container);\n    });\n    this.state.carousels = [];\n  }\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Swipix;\n} else {\n  window.Swipix = Swipix;\n}"],"names":["Swipix","constructor","config","this","container","nextButton","prevButton","loop","infiniteLoop","speed","slidesPerView","default","gap","slidesToMove","autoplay","enabled","delay","pauseOnInteraction","pauseAfterInteraction","lazyMedia","lazyMediaOffset","lazyPix","lazyPixOffset","state","currentIndex","totalSlides","slideWidth","isAnimating","containerWidth","carousels","init","containerSelector","selector","document","querySelectorAll","forEach","_observeInit","_initSingleCarousel","window","addEventListener","_handleResize","bind","carouselData","_setupAutoplay","observer","IntersectionObserver","entries","entry","isIntersecting","unobserve","threshold","rootMargin","observe","wrapper","querySelector","slides","length","console","error","style","visibility","originalSlides","Array","from","map","slide","index","setAttribute","isInfinite","clonedSlides","realSlidesOffset","autoplayInterval","autoplayHandlers","tabGroups","isVisible","push","_applyStyles","_setupInfiniteLoop","_calculateDimensions","transition","_positionSlides","offsetWidth","_initNavigation","_initTouchEvents","tabsConfig","_initTabsGroups","_observeVisibility","pauseHandler","_pauseAutoplay","removeEventListener","resumeHandler","_startAutoplay","_lazyLoadMedia","visibilityObserver","setInterval","next","clearInterval","start","end","slice","media","dataSrc","getAttribute","removeAttribute","tagName","toLowerCase","load","tabsConfigOption","tabConfigs","isArray","tabsContainer","warn","buttons","buttonSelector","children","btn","targetSlide","mapping","slideTo","_updateTabsActiveGroup","_updateTabsActive","group","activeIndex","Math","max","min","activeClass","rangeMapping","selectedTab","i","classList","add","remove","_clearClonedSlides","breakpointValues","Object","values","cloneCount","beginClones","slideIndex","clone","cloneNode","appendChild","endClones","insertBefore","firstChild","parentNode","removeChild","overflow","position","display","willChange","flexShrink","marginRight","viewportWidth","innerWidth","breakpoints","keys","filter","bp","parseInt","sort","a","b","totalGapSpace","width","translateX","transform","_checkInfiniteLoopReset","endThreshold","nextBtn","prevBtn","prev","startX","moveX","isDragging","initialTransform","handleDragStart","e","targetTag","target","includes","preventDefault","type","touches","clientX","getComputedStyle","getPropertyValue","matrix","DOMMatrix","m41","cursor","handleDragMove","diff","adjustedDiff","maxIndex","handleDragEnd","changedTouches","isAtStart","isAtEnd","abs","event","CustomEvent","detail","carousel","dispatchEvent","passive","eventHandlers","_getCarouselData","find","data","setTimeout","goTo","targetIndex","totalRealSlides","targetRealIndex","updateConfig","newConfig","undefined","destroy","newContainer","replaceChild","module","exports"],"mappings":"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"}